<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="以下内容为《Java加密与解密的艺术》一书与慕课网“搞定Java加解密”的学习笔记，其中大部分程序来自网络。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java加密与解密概要01">
<meta property="og:url" content="http://yoursite.com/2017/06/14/Java加密与解密概要01/index.html">
<meta property="og:site_name" content="Yuyublog">
<meta property="og:description" content="以下内容为《Java加密与解密的艺术》一书与慕课网“搞定Java加解密”的学习笔记，其中大部分程序来自网络。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/Java加密与解密概要01/encryptionbase64.png">
<meta property="og:image" content="http://yoursite.com/images/Java加密与解密概要01/encryptionBASE64_example01.png">
<meta property="og:image" content="http://yoursite.com/images/Java加密与解密概要01/encryptionBASE64_example02.png">
<meta property="og:updated_time" content="2019-04-08T06:31:11.915Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java加密与解密概要01">
<meta name="twitter:description" content="以下内容为《Java加密与解密的艺术》一书与慕课网“搞定Java加解密”的学习笔记，其中大部分程序来自网络。">
<meta name="twitter:image" content="http://yoursite.com/images/Java加密与解密概要01/encryptionbase64.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/14/Java加密与解密概要01/">





  <title>Java加密与解密概要01 | Yuyublog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuyublog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/14/Java加密与解密概要01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yu yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuyublog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java加密与解密概要01</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-14T15:03:01+08:00">
                2017-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/加密与解密/" itemprop="url" rel="index">
                    <span itemprop="name">加密与解密</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>以下内容为《Java加密与解密的艺术》一书与慕课网“搞定Java加解密”的学习笔记，其中大部分程序来自网络。</p>
</blockquote>
<a id="more"></a>
<h2 id="Java加密与解密概要01"><a href="#Java加密与解密概要01" class="headerlink" title="Java加密与解密概要01"></a>Java加密与解密概要01</h2><h3 id="一些基础"><a href="#一些基础" class="headerlink" title="一些基础"></a>一些基础</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E5%85%8B%E9%9C%8D%E5%A4%AB%E5%8E%9F%E5%89%87" target="_blank" rel="noopener">科克霍夫原则</a>：数据的安全基于密钥而不是算法的保密。即系统安全取决于密钥，算法公开，密钥保密。这也是现代密码学设计的基本原则；</li>
<li>分组密码：将要加密的内容分为固定长度的组，用同一密钥和算法对每一组加密；多用于网络加密；</li>
<li>流密码（序列密码）：加密时每次加密一个字节，即逐位加密；</li>
</ul>
<h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><h4 id="Base64原理"><a href="#Base64原理" class="headerlink" title="Base64原理"></a>Base64原理</h4><ul>
<li>Base64就是一种 基于64个可打印字符来表示二进制数据的表示方法；</li>
<li><p>字符选用了”A-Z、a-z、0-9、+、/“64个可打印字符。数值代表字符的索引，这个是标准Base64协议规定的，不能更改</p>
<p>  <img src="\images\Java加密与解密概要01\encryptionbase64.png" alt="Base64编码表"></p>
</li>
<li><p>Base64的实现：用4个Base64编码表示3个ASCII码字符，具体如下：</p>
<p>  <img src="\images\Java加密与解密概要01\encryptionBASE64_example01.png" alt="Base64编码表"></p>
</li>
<li><p>以上例子是基于内容可以被3整除的情况下，但如果内如无法被3整除，则需要补0；理论上Base64编码是4位1组，如果不够4位则以=补位（其实不补=也不影响解码，但=可以作为结束符号使用）：</p>
<p>  <img src="\images\Java加密与解密概要01\encryptionBASE64_example02.png" alt="Base64编码表"></p>
</li>
<li><p>Base64在Java中的实现：Jdk、Commons Codec、Bouncy Castle；</p>
</li>
<li>Base64的应用场景：email、中文或图片传输等；</li>
</ul>
<h4 id="Base64的JDK实现"><a href="#Base64的JDK实现" class="headerlink" title="Base64的JDK实现"></a>Base64的JDK实现</h4><pre><code>package info.yuyublog.encryption;

import com.sun.org.apache.xml.internal.security.utils.Base64;

public class Base64Test {

    public static void main(String[] args) throws Exception     
    {     
        String asB64 = Base64.encode(&quot;some string&quot;.getBytes(&quot;utf-8&quot;));

        System.out.println(asB64);      

        byte[] btarrB64 = Base64.decode(asB64);

        String resB64 = new String(btarrB64);

        System.out.println(resB64);
    }
}
</code></pre><p>输出结果：</p>
<pre><code>c29tZSBzdHJpbmc=
some string
</code></pre><h3 id="消息摘要算法"><a href="#消息摘要算法" class="headerlink" title="消息摘要算法"></a>消息摘要算法</h3><ul>
<li>特点：<ul>
<li>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。</li>
<li>一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。</li>
<li>只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息（不可逆性）。</li>
</ul>
</li>
<li>分为MD(Message Digest),SHA(Secure Hash Algorithm),MAC(Message Authentication code)</li>
</ul>
<h4 id="MD算法（Message-Digest）"><a href="#MD算法（Message-Digest）" class="headerlink" title="MD算法（Message Digest）"></a>MD算法（Message Digest）</h4><ul>
<li>MD算法包含MD2、MD4、MD5等算法，MD5由MD4发展而来，MD4由MD2发展而来，现在常用的是MD5算法，不过由于密码学的发展，MD5的安全性也已大大下降；</li>
<li>有关MD5算法的原理与具体实现可以参考<a href="http://blog.csdn.net/xiaofengcanyuexj/article/details/37698801" target="_blank" rel="noopener">这篇博客</a>。</li>
<li>MD5一般用于传输文件的一致性验证（例如下载网站上附加的MD5）、数字证书、安全访问认证等（安全访问认证由于用户密码比较简单的话极易利用<a href="http://baike.sogou.com/v8046018.htm?fromTitle=%E5%BD%A9%E8%99%B9%E8%A1%A8" target="_blank" rel="noopener">彩虹表</a>破解，所以安全性较低，使用时最好使用<a href="https://libuchao.com/2013/07/05/password-salt" target="_blank" rel="noopener">加盐加密</a>）。</li>
</ul>
<h4 id="MD5算法的JDK实现"><a href="#MD5算法的JDK实现" class="headerlink" title="MD5算法的JDK实现"></a>MD5算法的JDK实现</h4><pre><code>package info.yuyublog.encryption;

import java.security.MessageDigest;

public class MD5Test {
    public final static String MD5(String s) {
        char hexDigits[]={&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;};       
        try {
            byte[] btInput = s.getBytes();
            // 获得MD5摘要算法的 MessageDigest 对象
            MessageDigest mdInst = MessageDigest.getInstance(&quot;MD5&quot;);
            // 使用指定的字节更新摘要
            mdInst.update(btInput);
            // 获得密文
            byte[] md = mdInst.digest();
            // 把密文转换成十六进制的字符串形式
            int j = md.length;
            char str[] = new char[j * 2];
            int k = 0;
            for (int i = 0; i &lt; j; i++) {
                byte byte0 = md[i];
                str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];
                str[k++] = hexDigits[byte0 &amp; 0xf];
            }
            return new String(str);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    public static void main(String[] args) {
        System.out.println(MD5Test.MD5(&quot;加密&quot;));
    }
}
</code></pre><p>输出结果:</p>
<pre><code>56563EDF23B9D717DC63981B8836FC60
</code></pre><h4 id="SHA算法（Secure-Hash-Algorithm）"><a href="#SHA算法（Secure-Hash-Algorithm）" class="headerlink" title="SHA算法（Secure Hash Algorithm）"></a>SHA算法（Secure Hash Algorithm）</h4><ul>
<li><a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F" target="_blank" rel="noopener">SHA算法</a>严格意义上来说可以分为SHA-1、SHA-2、SHA-3三代算法，其中后缀的数字代表代数。SHA-1是第一代算法，目前<a href="http://www.infoq.com/cn/news/2017/02/google-first-sha1-collision" target="_blank" rel="noopener">谷歌已经宣告实现了对其的碰撞</a>，安全性相对较低。SHA-2是第二代算法的统称，包含SHA-224、SHA-256、SHA-384、SHA-512四个算法。目前SHA-1与SHA-2这5个算法是比较常用的。</li>
<li>SHA算法现在一般用于网站根证书(SHA-1即将淘汰但仍占有很大一部分，SHA-2是趋势)、加密数据传输等等。</li>
</ul>
<h4 id="SHA-256算法JDK实现"><a href="#SHA-256算法JDK实现" class="headerlink" title="SHA-256算法JDK实现"></a>SHA-256算法JDK实现</h4><pre><code>package info.yuyublog.encryption;

import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class SHA256Test {
     /**
     *  利用java原生的摘要实现SHA256加密
     * @param str 加密后的报文
     * @return
     */
    public static String getSHA256StrJava(String str){
        MessageDigest messageDigest;
        String encodeStr = &quot;&quot;;
        try {
            messageDigest = MessageDigest.getInstance(&quot;SHA-256&quot;);
            messageDigest.update(str.getBytes(&quot;UTF-8&quot;));
            encodeStr = byte2Hex(messageDigest.digest());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return encodeStr;
    }

    /**
     * 将byte转为16进制
     * @param bytes
     * @return
     */
    private static String byte2Hex(byte[] bytes){
        StringBuffer stringBuffer = new StringBuffer();
        String temp = null;
        for (int i=0;i&lt;bytes.length;i++){
            temp = Integer.toHexString(bytes[i] &amp; 0xFF);
            if (temp.length()==1){
                //1得到一位的进行补0操作
                stringBuffer.append(&quot;0&quot;);
            }
            stringBuffer.append(temp);
        }
        return stringBuffer.toString();
    }
    public static void main(String[] args) {
        String src = new String(&quot;Hello world!&quot;);
        String des = getSHA256StrJava(src);
        System.out.println(des);
    }
}
</code></pre><p>输出结果:</p>
<pre><code>c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a
</code></pre><h4 id="MAC算法（Message-Authentication-Code）"><a href="#MAC算法（Message-Authentication-Code）" class="headerlink" title="MAC算法（Message Authentication Code）"></a>MAC算法（Message Authentication Code）</h4><ul>
<li>含有密钥散列函数算法，兼容了MD与SHA算分的特性，并在此基础上加入了密钥；</li>
</ul>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>加密密钥与解密密钥相同，加密算法是解密算法的逆运算。常用的有DES、AES与PBE.</p>
<h4 id="DES算法（Data-Encryption-Standard）"><a href="#DES算法（Data-Encryption-Standard）" class="headerlink" title="DES算法（Data Encryption Standard）"></a>DES算法（Data Encryption Standard）</h4><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96" target="_blank" rel="noopener">DES算法</a>现在是不安全的（已经有实例化的破译机），但它是所有对称加密算法的起源，各种加密算法均由研究DES发展而来。</li>
<li>DES算法的原理可以在<a href="http://blog.csdn.net/qq_27570955/article/details/52442092" target="_blank" rel="noopener">这里</a>找到。</li>
</ul>
<h4 id="DES算法的JDK实现"><a href="#DES算法的JDK实现" class="headerlink" title="DES算法的JDK实现"></a>DES算法的JDK实现</h4><pre><code>package info.yuyublog.encryption;

import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;

public class DESTest {

    public static byte[] desCrypto(byte[] datasource, String password) {
        try {
            SecureRandom random = new SecureRandom();
            DESKeySpec desKey = new DESKeySpec(password.getBytes());
            // 创建一个密匙工厂，然后用它把DESKeySpec转换成
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);
            SecretKey securekey = keyFactory.generateSecret(desKey);
            // Cipher对象实际完成加密操作
            Cipher cipher = Cipher.getInstance(&quot;DES&quot;);
            // 用密匙初始化Cipher对象
            cipher.init(Cipher.ENCRYPT_MODE, securekey, random);
            // 获取数据并加密
            return cipher.doFinal(datasource);
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return null;
    }

    private static byte[] decrypt(byte[] src, String password) throws Exception {
        // DES算法要求有一个可信任的随机数源
        SecureRandom random = new SecureRandom();
        // 创建一个DESKeySpec对象
        DESKeySpec desKey = new DESKeySpec(password.getBytes());
        // 创建一个密匙工厂
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);
        // 将DESKeySpec对象转换成SecretKey对象
        SecretKey securekey = keyFactory.generateSecret(desKey);
        // Cipher对象实际完成解密操作
        Cipher cipher = Cipher.getInstance(&quot;DES&quot;);
        // 用密匙初始化Cipher对象
        cipher.init(Cipher.DECRYPT_MODE, securekey, random);
        // 开始解密操作
        return cipher.doFinal(src);
    }

    private static String byte2Hex(byte[] bytes){
        StringBuffer stringBuffer = new StringBuffer();
        String temp = null;
        for (int i=0;i&lt;bytes.length;i++){
            temp = Integer.toHexString(bytes[i] &amp; 0xFF);
            if (temp.length()==1){
                //1得到一位的进行补0操作
                stringBuffer.append(&quot;0&quot;);
            }
            stringBuffer.append(temp);
        }
        return stringBuffer.toString();
    }

    public static void main(String[] args) throws Exception {
        // 待加密内容
        String str = &quot;测试内容&quot;;
        // 密码，长度要是8的倍数
        String password = &quot;12345678&quot;;
        byte[] result = DESTest.desCrypto(str.getBytes(), password);
        System.out.println(&quot;加密后内容为：&quot; + byte2Hex(result));

        // 直接将如上内容解密
        try {
            byte[] decryResult = DESTest.decrypt(result, password);
            System.out.println(&quot;解密后内容为：&quot; + new String(decryResult));
        } catch (Exception e1) {
            e1.printStackTrace();
        }
    }
}
</code></pre><p>输出结果:</p>
<pre><code>加密后内容为：a5d37c3d8502d503cc7b1eb62cef4b79
解密后内容为：测试内容
</code></pre><h4 id="DESede"><a href="#DESede" class="headerlink" title="DESede"></a>DESede</h4><ul>
<li>DESede 即三重DES加密算法，也被称为3DES或者Triple DES。使用三(或两)个不同的密钥对数据块进行三次(或两次)DES加密(加密一次要比进行普通加密的三次要快)。三重DES的强度大约和112bit的密钥强度相当。通过迭代次数的提高了安全性，但同时也造成了加密效率低的问题。</li>
<li>到目前为止，还没有人给出攻击三重DES的有效方法。</li>
<li>三重DES有四种模型<ul>
<li>DES-EEE3，使用三个不同密钥，顺序进行三次加密变换。</li>
<li>DES-EDE3，使用三个不同密钥，依次进行加密-解密-加密变换。</li>
<li>DES-EEE2，其中密钥K1=K3，顺序进行三次加密变换。</li>
<li>DES-EDE2， 其中密钥K1=K3，依次进行加密-解密-加密变换。</li>
</ul>
</li>
</ul>
<h4 id="DESede-JDK实现"><a href="#DESede-JDK实现" class="headerlink" title="DESede JDK实现"></a>DESede JDK实现</h4><pre><code>package info.yuyublog.encryption;

import java.security.Key;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;

public class DESedeTest {
    private static final String KEY_ALGORITHM = &quot;DESede&quot;;  

    private static final String DEFAULT_CIPHER_ALGORITHM = &quot;DESede/ECB/ISO10126Padding&quot;;  

    /** 
     * 初始化密钥 
     *  
     * @return byte[] 密钥  
     * @throws Exception 
     */  
    public static byte[] initSecretKey() throws Exception{  
        //返回生成指定算法的秘密密钥的 KeyGenerator 对象  
        KeyGenerator kg = KeyGenerator.getInstance(KEY_ALGORITHM);  
        //初始化此密钥生成器，使其具有确定的密钥大小  
        kg.init(168);  
        //生成一个密钥  
        SecretKey  secretKey = kg.generateKey();  
        return secretKey.getEncoded();  
    }  

    /** 
     * 转换密钥 
     *  
     * @param key   二进制密钥 
     * @return Key  密钥 
     * @throws Exception 
     */  
    private static Key toKey(byte[] key) throws Exception{  
        //实例化DES密钥规则  
        DESedeKeySpec dks = new DESedeKeySpec(key);  
        //实例化密钥工厂  
        SecretKeyFactory skf = SecretKeyFactory.getInstance(KEY_ALGORITHM);  
        //生成密钥  
        SecretKey  secretKey = skf.generateSecret(dks);  
        return secretKey;  
    }  

    /** 
     * 加密 
     *  
     * @param data  待加密数据 
     * @param key   密钥 
     * @return byte[]   加密数据 
     * @throws Exception 
     */  
    public static byte[] encrypt(byte[] data,Key key) throws Exception{  
        return encrypt(data, key,DEFAULT_CIPHER_ALGORITHM);  
    }  

    /** 
     * 加密 
     *  
     * @param data  待加密数据 
     * @param key   二进制密钥 
     * @return byte[]   加密数据 
     * @throws Exception 
     */  
    public static byte[] encrypt(byte[] data,byte[] key) throws Exception{  
        return encrypt(data, key,DEFAULT_CIPHER_ALGORITHM);  
    }  
</code></pre><p>​<br>        /** </p>
<pre><code> * 加密 
 *  
 * @param data  待加密数据 
 * @param key   二进制密钥 
 * @param cipherAlgorithm   加密算法/工作模式/填充方式 
 * @return byte[]   加密数据 
 * @throws Exception 
 */  
public static byte[] encrypt(byte[] data,byte[] key,String cipherAlgorithm) throws Exception{  
    //还原密钥  
    Key k = toKey(key);  
    return encrypt(data, k, cipherAlgorithm);  
}  

/** 
 * 加密 
 *  
 * @param data  待加密数据 
 * @param key   密钥 
 * @param cipherAlgorithm   加密算法/工作模式/填充方式 
 * @return byte[]   加密数据 
 * @throws Exception 
 */  
public static byte[] encrypt(byte[] data,Key key,String cipherAlgorithm) throws Exception{  
    //实例化  
    Cipher cipher = Cipher.getInstance(cipherAlgorithm);  
    //使用密钥初始化，设置为加密模式  
    cipher.init(Cipher.ENCRYPT_MODE, key);  
    //执行操作  
    return cipher.doFinal(data);  
}  
</code></pre><p>​<br>​<br>        /** </p>
<pre><code>     * 解密 
     *  
     * @param data  待解密数据 
     * @param key   二进制密钥 
     * @return byte[]   解密数据 
     * @throws Exception 
     */  
    public static byte[] decrypt(byte[] data,byte[] key) throws Exception{  
        return decrypt(data, key,DEFAULT_CIPHER_ALGORITHM);  
    }  

    /** 
     * 解密 
     *  
     * @param data  待解密数据 
     * @param key   密钥 
     * @return byte[]   解密数据 
     * @throws Exception 
     */  
    public static byte[] decrypt(byte[] data,Key key) throws Exception{  
        return decrypt(data, key,DEFAULT_CIPHER_ALGORITHM);  
    }  

    /** 
     * 解密 
     *  
     * @param data  待解密数据 
     * @param key   二进制密钥 
     * @param cipherAlgorithm   加密算法/工作模式/填充方式 
     * @return byte[]   解密数据 
     * @throws Exception 
     */  
    public static byte[] decrypt(byte[] data,byte[] key,String cipherAlgorithm) throws Exception{  
        //还原密钥  
        Key k = toKey(key);  
        return decrypt(data, k, cipherAlgorithm);  
    }  

    /** 
     * 解密 
     *  
     * @param data  待解密数据 
     * @param key   密钥 
     * @param cipherAlgorithm   加密算法/工作模式/填充方式 
     * @return byte[]   解密数据 
     * @throws Exception 
     */  
    public static byte[] decrypt(byte[] data,Key key,String cipherAlgorithm) throws Exception{  
        //实例化  
        Cipher cipher = Cipher.getInstance(cipherAlgorithm);  
        //使用密钥初始化，设置为解密模式  
        cipher.init(Cipher.DECRYPT_MODE, key);  
        //执行操作  
        return cipher.doFinal(data);  
    }  

    private static String  showByteArray(byte[] data){  
        if(null == data){  
            return null;  
        }  
        StringBuilder sb = new StringBuilder(&quot;{&quot;);  
        for(byte b:data){  
            sb.append(b).append(&quot;,&quot;);  
        }  
        sb.deleteCharAt(sb.length()-1);  
        sb.append(&quot;}&quot;);  
        return sb.toString();  
    }  

    private static String byte2Hex(byte[] bytes){
        StringBuffer stringBuffer = new StringBuffer();
        String temp = null;
        for (int i=0;i&lt;bytes.length;i++){
            temp = Integer.toHexString(bytes[i] &amp; 0xFF);
            if (temp.length()==1){
                //1得到一位的进行补0操作
                stringBuffer.append(&quot;0&quot;);
            }
            stringBuffer.append(temp);
        }
        return stringBuffer.toString();
    }

    public static void main(String[] args) throws Exception {  
        byte[] key = initSecretKey();  
        System.out.println(&quot;key：&quot;+ showByteArray(key));  

        Key k = toKey(key);  

        String data =&quot;123456789&quot;;  
        System.out.println(&quot;加密前数据: string:&quot;+data);  
        System.out.println(&quot;加密前数据: byte[]:&quot;+showByteArray(data.getBytes()));  
        System.out.println();  
        byte[] encryptData = encrypt(data.getBytes(), k);  
        System.out.println(&quot;加密后数据: byte[]:&quot;+showByteArray(encryptData));  
        System.out.println(&quot;加密后数据: hexStr:&quot;+byte2Hex(encryptData));  
        System.out.println();  
        byte[] decryptData = decrypt(encryptData, k);  
        System.out.println(&quot;解密后数据: byte[]:&quot;+showByteArray(decryptData));  
        System.out.println(&quot;解密后数据: string:&quot;+new String(decryptData));  

    }  
}
</code></pre><p>输出结果:</p>
<pre><code>key：{50,-33,-50,35,26,-56,104,121,47,103,112,31,-88,69,-88,55,-22,50,-88,-110,-23,-101,82,-122}
加密前数据: string:123456789
加密前数据: byte[]:{49,50,51,52,53,54,55,56,57}
加密后数据: byte[]:{66,71,-7,21,-21,-34,72,55,67,75,-41,-122,117,92,96,-29}
加密后数据: hexStr:4247f915ebde4837434bd786755c60e3
解密后数据: byte[]:{49,50,51,52,53,54,55,56,57}
解密后数据: string:123456789
</code></pre><h4 id="AES算法（Advanced-Encryption-Standard）"><a href="#AES算法（Advanced-Encryption-Standard）" class="headerlink" title="AES算法（Advanced Encryption Standard）"></a>AES算法（Advanced Encryption Standard）</h4><ul>
<li>又称为Rijndael算法，由于DESede的低效与较慢的运算速度满足不了安全需求，AES应运而生。DES使用56位密钥，比较容易被破解，而AES可以使用128、192、和256位密钥，并且用128位分组加密和解密数据，所以安全性较高，目前已经变成目前对称加密中最流行算法之一；</li>
<li>AES目前尚未有官方的破译报告；</li>
<li>原理参见<a href="http://www.cnblogs.com/luop/p/4334160.html" target="_blank" rel="noopener">这里</a>；</li>
<li>现在常应用于Secure SHell等;</li>
</ul>
<h4 id="AES-JDK实现"><a href="#AES-JDK实现" class="headerlink" title="AES JDK实现"></a>AES JDK实现</h4><pre><code>package info.yuyublog.encryption;

import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class AESTest {
    /**
     * 加密
     * 
     * @param content 需要加密的内容
     * @param key     加密密码
     * @return
     */
    public static byte[] encrypt(String content, String key) {
        try {
            KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);
            kgen.init(128, new java.security.SecureRandom(key.getBytes()));
            SecretKey secretKey = kgen.generateKey();
            byte[] enCodeFormat = secretKey.getEncoded();
            SecretKeySpec secretKeySpec = new SecretKeySpec(enCodeFormat, &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);// 创建密码器
            byte[] byteContent = content.getBytes(&quot;UTF-8&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);// 初始化
            byte[] result = cipher.doFinal(byteContent);
            return result; // 加密
        } catch (Exception e) {
            e.printStackTrace();
        } 
        return null;
    }
    /**
     - 解密
     - 
     - @param content 待解密内容
     - @param key     解密密钥
     - @return
     */
    public static byte[] decrypt(byte[] content, String key) {
        try {
            KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);
            kgen.init(128, new java.security.SecureRandom(key.getBytes()));
            SecretKey secretKey = kgen.generateKey();
            byte[] enCodeFormat = secretKey.getEncoded();
            SecretKeySpec secretKeySpec = new SecretKeySpec(enCodeFormat, &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);// 创建密码器
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);// 初始化
            byte[] result = cipher.doFinal(content);
            return result; // 加密
        } catch (Exception e) {
            e.printStackTrace();
        } 
        return null;
    }

    /**
     - 字符串加密
     - 
     - @param content  要加密的字符串
     - @param key      加密的AES Key
     - @return
     */
    public static String encryptString(String content, String key) {
        return parseByte2HexStr(encrypt(content, key));
    }

    /**
     - 字符串解密
     - 
     - @param content   要解密的字符串
     - @param key       解密的AES Key
     - @return
     */
    public static String decryptString(String content, String key) {
        byte[] decryptFrom = parseHexStr2Byte(content);
        byte[] decryptResult = decrypt(decryptFrom, key);
        return new String(decryptResult);
    }

    /**
     - 将16进制转换为二进制
     - 
     - @param hexStr
     - @return
     */
    public static byte[] parseHexStr2Byte(String hexStr) {
        if (hexStr.length() &lt; 1)
            return null;
        byte[] result = new byte[hexStr.length() / 2];
        for (int i = 0; i &lt; hexStr.length() / 2; i++) {
            int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16);
            int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16);
            result[i] = (byte) (high * 16 + low);
        }
        return result;
    }

    /**
     - 将二进制转换成16进制
     - 
     - @param buf
     - @return
     */
    public static String parseByte2HexStr(byte buf[]) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; buf.length; i++) {
            String hex = Integer.toHexString(buf[i] &amp; 0xFF);
            if (hex.length() == 1) {
                hex = &apos;0&apos; + hex;
            }
            sb.append(hex.toUpperCase());
        }
        return sb.toString();
    }

    public static void main(String aregs[]) {
        String content = &quot;协议加密Test&amp;123&quot;;
        String key = &quot;25d55ad283aa400af464c76d713c07ad&quot;;
        try {
            // 加密
            System.out.println(&quot;加密前：&quot; + content);
            String encrypt = AESTest.encryptString(content, key);
            System.out.println(&quot;加密后：&quot; + encrypt);
            // 解密
            String decrypt = AESTest.decryptString(encrypt, key);
            System.out.println(&quot;解密后：&quot; + decrypt);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}
</code></pre><p>输出结果:</p>
<pre><code>加密前：协议加密Test&amp;123
加密后：7D07155438880C51E50433C17D9AFF8DCB2A9596AF46B2ABA33C18918053E3E0
解密后：协议加密Test&amp;123
</code></pre><h4 id="PBE（Password-Based-Encryption）"><a href="#PBE（Password-Based-Encryption）" class="headerlink" title="PBE（Password Based Encryption）"></a>PBE（Password Based Encryption）</h4><ul>
<li>PBE算法是一种基于口令的加密算法，其特点在于口令是由用户自己掌握的，采用随机数杂凑多重加密等方法保证数据的安全性。</li>
<li>PBE算法没有密钥的概念，密钥在其它对称加密算法中是经过算法计算得出来的，PBE算法则是使用口令替代了密钥。PBE算法并没有真正构建新的加密/解密算法，而是对我们已经知道的对称加密算法（如DES算法）做了包装。使用PBE算法对数据做加解密操作的时候，其实是使用了DES或者是AES等其它对称加密算法做了相应的操作。</li>
<li>由于仅仅使用口令十分不安全，所以PBE中引入了盐来提升安全性；</li>
</ul>
<h4 id="PBE-JDK实现"><a href="#PBE-JDK实现" class="headerlink" title="PBE JDK实现"></a>PBE JDK实现</h4><pre><code>package info.yuyublog.encryption;

import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;

public class PBETest {
    static final String KEY_ALGORITHM = &quot;PBEWithMD5AndDES&quot;;
    static byte[] salt = &quot;hello123&quot;.getBytes(); // 盐：Salt must be 8 bytes long
    static int iterationCount = 888; // 循环次数
    static Cipher cipher;

    public static void main(String[] args) throws Exception {
        byte[] encrypt = encrypt(&quot;PBETest&quot;);
        System.out.println(&quot;PBE加密后：&quot; + Arrays.toString(encrypt));

        System.out.println(&quot;PBE解密后：&quot; + decrypt(encrypt));
    }

    /**
     * 使用PBE 算法 加密
     * 
     * @return 加密后的字符数组
     * @throws Exception
     */
    static byte[] encrypt(String str) throws Exception {
        cipher = Cipher.getInstance(KEY_ALGORITHM);

        // 使用SecretKeyFactory 生成key
        SecretKeyFactory factory = SecretKeyFactory.getInstance(KEY_ALGORITHM);
        PBEKeySpec keySpec = new PBEKeySpec(&quot;password&quot;.toCharArray());
        SecretKey key = factory.generateSecret(keySpec);
        System.out.println(&quot;key:&quot; + Arrays.toString(key.getEncoded()));

        cipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(salt, iterationCount));// 使用加密模式初始化                             
        return cipher.doFinal(str.getBytes()); // 按单部分操作加密或解密数据，或者结束一个多部分操作。
    }

    /**
     * 
     * @param encrypt
     * @return
     * @throws Exception
     */
    static String decrypt(byte[] encrypt) throws Exception {
        cipher = Cipher.getInstance(KEY_ALGORITHM);

        // 使用SecretKeyFactory 生成key
        SecretKeyFactory factory = SecretKeyFactory.getInstance(KEY_ALGORITHM);
        PBEKeySpec keySpec = new PBEKeySpec(&quot;password&quot;.toCharArray());
        SecretKey key = factory.generateSecret(keySpec);
        System.out.println(&quot;key:&quot; + Arrays.toString(key.getEncoded()));

        cipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(salt, iterationCount));// 使用加密模式初始化
        byte[] result = cipher.doFinal(encrypt); // 按单部分操作加密或解密数据，或者结束一个多部分操作。

        return new String(result);
    }
}
</code></pre><p>输出结果：</p>
<pre><code>key:[112, 97, 115, 115, 119, 111, 114, 100]
PBE加密后：[-4, 57, 100, 25, 91, 55, 112, -76]
key:[112, 97, 115, 115, 119, 111, 114, 100]
PBE解密后：PBETest
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/27/数据结构02/" rel="next" title="数据结构02">
                <i class="fa fa-chevron-left"></i> 数据结构02
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/14/Java加密与解密概要02/" rel="prev" title="Java加密与解密概要02">
                Java加密与解密概要02 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/blog/avatar.jpg" alt="Yu yu">
            
              <p class="site-author-name" itemprop="name">Yu yu</p>
              <p class="site-description motion-element" itemprop="description">yuyublog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java加密与解密概要01"><span class="nav-number">1.</span> <span class="nav-text">Java加密与解密概要01</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一些基础"><span class="nav-number">1.1.</span> <span class="nav-text">一些基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Base64"><span class="nav-number">1.2.</span> <span class="nav-text">Base64</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Base64原理"><span class="nav-number">1.2.1.</span> <span class="nav-text">Base64原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Base64的JDK实现"><span class="nav-number">1.2.2.</span> <span class="nav-text">Base64的JDK实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息摘要算法"><span class="nav-number">1.3.</span> <span class="nav-text">消息摘要算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MD算法（Message-Digest）"><span class="nav-number">1.3.1.</span> <span class="nav-text">MD算法（Message Digest）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MD5算法的JDK实现"><span class="nav-number">1.3.2.</span> <span class="nav-text">MD5算法的JDK实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SHA算法（Secure-Hash-Algorithm）"><span class="nav-number">1.3.3.</span> <span class="nav-text">SHA算法（Secure Hash Algorithm）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SHA-256算法JDK实现"><span class="nav-number">1.3.4.</span> <span class="nav-text">SHA-256算法JDK实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MAC算法（Message-Authentication-Code）"><span class="nav-number">1.3.5.</span> <span class="nav-text">MAC算法（Message Authentication Code）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对称加密算法"><span class="nav-number">1.4.</span> <span class="nav-text">对称加密算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DES算法（Data-Encryption-Standard）"><span class="nav-number">1.4.1.</span> <span class="nav-text">DES算法（Data Encryption Standard）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DES算法的JDK实现"><span class="nav-number">1.4.2.</span> <span class="nav-text">DES算法的JDK实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DESede"><span class="nav-number">1.4.3.</span> <span class="nav-text">DESede</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DESede-JDK实现"><span class="nav-number">1.4.4.</span> <span class="nav-text">DESede JDK实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AES算法（Advanced-Encryption-Standard）"><span class="nav-number">1.4.5.</span> <span class="nav-text">AES算法（Advanced Encryption Standard）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AES-JDK实现"><span class="nav-number">1.4.6.</span> <span class="nav-text">AES JDK实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PBE（Password-Based-Encryption）"><span class="nav-number">1.4.7.</span> <span class="nav-text">PBE（Password Based Encryption）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PBE-JDK实现"><span class="nav-number">1.4.8.</span> <span class="nav-text">PBE JDK实现</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yu yu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
